/*
# _____     ___ ____     ___ ____
#  ____|   |    ____|   |        | |____|
# |     ___|   |____ ___|    ____| |    \    PS2DEV Open Source Project.
#-----------------------------------------------------------------------
# Copyright 2005, ps2dev - http://www.ps2dev.org
# Licenced under GNU Library General Public License version 2
# Review ps2sdk README & LICENSE files for further details.
#
# $Id$
# audsrv IOP server
*/

#include <stdio.h>
#include <thbase.h>
#include <thsemap.h>
#include <loadcore.h>
#include <sysmem.h>
#include <intrman.h>
#include <sifcmd.h>
#include <libsd.h>

#include <audsrv.h>
#include "audsrv.c.h"
#include "upsamplers.h"
#include "hw.h"

/**
 * \file audsrv.c
 * \author gawd (Gil Megidish)
 * \date 04-24-05
 */

#define VERSION "0.75"

/* globals */
static int core1_volume = MAX_VOLUME;   ///< core1 volume when playing
static int core1_freq = 0;              ///< frequency set by user
static int core1_bits = 0;              ///< bits per sample, set by user
static int core1_channels = 0;          ///< number of audio channels
static int core1_cdvolume = 0;          ///< core1 cdrom volume, when playing
static int core1_sample_shift = 0;      ///< shift count from bytes to samples

/* status */
static int initialized = 0;             ///< initialization status
static int playing = 0;                 ///< playing (not mute) status

/* ring buffer properties */
/** size of ring buffer in bytes */
static char ringbuf[20480];             ///< ring buffer itself
static int ringbuf_size = sizeof(ringbuf);
static int readpos;                     ///< reading head pointer
static int writepos;                    ///< writing head pointer

static int play_tid = 0;                ///< playing thread id
static int queue_sema = 0;              ///< semaphore for wait_audio()
static int transfer_sema = 0;           ///< SPU2 transfer complete semaphore

static int format_changed = 0;          ///< boolean to notify when format has changed

/** double buffer for streaming */
static char spubuf[0x800] __attribute__((aligned (64)));

/* rpc server variables */
static int rpc_buffer[18000/4];         ///< buffer for RPC DMA
static SifRpcDataQueue_t qd;            ///< RPC thread variables
static SifRpcServerData_t sd0;          ///< RPC thread variables

/** Find the minimum value between A and B */
#define MIN(a,b) ((a) <= (b)) ? (a) : (b)

/* forward declarations */
static void play_thread(void *arg);
static int create_thread(void *func, int priority, void *param);

/** Transfer complete callback.
    @param arg     not used
    @returns true, always

    Generated by SPU2, when a block was transmitted and now putting
    to upload a second block to the other buffer.
*/
static int transfer_complete(void *arg)
{
	iSignalSema(transfer_sema);
	return 1;
}

/** Apply volume changes, or keep mute if not playing
*/
static void update_volume()
{
	int vol;

	vol = playing ? core1_volume : 0;
	sceSdSetParam(SD_CORE_1 | SD_P_BVOLL, vol);
	sceSdSetParam(SD_CORE_1 | SD_P_BVOLR, vol);
}

/** Stops all audio playing
    @returns 0, always

    Mutes output and stops accepting audio blocks
*/
int audsrv_stop_audio()
{
	/* audio is still playing, just mute */
	playing = 0;
	update_volume();

	return AUDSRV_ERR_NOERROR;
}

/** Checks if the format noted by frequency and depth is supported

    @param freq     frequency in hz
    @param bits     bits per sample (8, 16)
    @param channels channels
    @returns positive on success, zero value on failure
*/
int audsrv_format_ok(int freq, int bits, int channels)
{
	if (find_upsampler(freq, bits, channels) != NULL)
	{
		return 1;
	}

	/* unsupported format */
	return 0;
}

/** Configures audio stream
    @param freq     frequency in hz
    @param bits     bits per sample (8, 16)
    @param channels number of channels
    @returns 0 on success, negative if configuration is not supported

    This sets up audsrv to accept stream in this format and convert
    it to SPU2's native format if required. Note: it is possible to
    change the format at any point. You might want to stop audio prior
    to that, to prevent mismatched audio output.
*/
int audsrv_set_format(int freq, int bits, int channels)
{
	int feed_size;

	if (audsrv_format_ok(freq, bits, channels) == 0)
	{
		return -AUDSRV_ERR_FORMAT_NOT_SUPPORTED;
	}

	/* update shift-right count */
	core1_sample_shift = 0;
	if (bits == 16)
	{
		core1_sample_shift++;
	}

	if (channels == 2)
	{
		core1_sample_shift++;
	}

	core1_freq = freq;
	core1_bits = bits;
	core1_channels = channels;

	/* set ring buffer size to 20 iterations worth of data (~100 ms) */
	feed_size = (256 * (core1_freq << core1_sample_shift)) / 48000;
	ringbuf_size = feed_size * 20;
	readpos = writepos = 0;
	
	printf("audsrv: freq %d bits %d channels %d ringbuf_sz %d feed_size %d shift %d\n", freq, bits, channels, ringbuf_size, feed_size, core1_sample_shift);

	format_changed = 1;
	return AUDSRV_ERR_NOERROR;
}

/** Initializes audsrv library
    @returns 0 on success
*/
int audsrv_init()
{
	if (initialized)
	{
		return 0;
	}

	/* initialize libsd */
	if (sceSdInit(SD_INIT_COLD) < 0) 
	{
		printf("audsrv: failed to initialize libsd\n");
		return -1;
	}

	readpos = 0;
	writepos = 0;

	/* initialize transfer_complete's semaphore */
	transfer_sema = CreateMutex(0);
	if (transfer_sema <= 0)
	{
		return AUDSRV_ERR_OUT_OF_MEMORY;
	}

	queue_sema = CreateMutex(0);
	if (queue_sema <= 0)
	{
		DeleteSema(transfer_sema);
		return AUDSRV_ERR_OUT_OF_MEMORY;
	}

	//SdSetCoreAttr(SD_CORE_1|SD_C_NOISE_CLK,0);

	/* audio is always playing in the background. trick is to 
	 * set the data input volume to zero
	 */
	audsrv_stop_audio();
	sceSdSetParam(SD_CORE_1 | SD_P_MVOLL, MAX_VOLUME);
	sceSdSetParam(SD_CORE_1 | SD_P_MVOLR, MAX_VOLUME);

	/* initialize transfer-complete callback */
	sceSdSetTransCallback(SD_CORE_1, (void *)transfer_complete);

	/* kick streaming */
	sceSdBlockTrans(SD_CORE_1, SD_BLOCK_LOOP, spubuf, SPU_BUF_SZ);

	/* default to SPU's native */
	audsrv_set_format(48000, 16, 2);

	play_tid = create_thread(play_thread, 39, 0);
	printf("audsrv: playing thread %x started\n", play_tid);

	printf("audsrv: kickstarted\n");

	initialized = 1;
	return AUDSRV_ERR_NOERROR;
}

/** Returns the number of bytes that can be queued
    @returns sample count
    
    Returns the number of bytes that are available in the ring buffer. This
    is the total bytes that can be queued, without collision of the reading
    head with the writing head.
*/
int audsrv_available()
{
	if (writepos < readpos)
	{
		return readpos - writepos;
	}
	else
	{
		return (ringbuf_size - (writepos - readpos));
	}
}

/** Blocks until there is enough space to enqueue chunk
    @param buflen   size of chunk requested to be enqueued (in bytes)
    @returns error status code
    
    Blocks until there are enough space to store the upcoming chunk
    in audsrv's internal ring buffer.
*/
int audsrv_wait_audio(int buflen)
{
	if (queue_sema <= 0)
	{
		/* not initialized */
		return AUDSRV_ERR_NOT_INITIALIZED;
	}

	if (ringbuf_size < buflen)
	{
		/* this will never happen */
		return AUDSRV_ERR_ARGS;
	}

	while (1)
	{
		if (audsrv_available() > buflen)
		{
			/* enough space! */
			return AUDSRV_ERR_NOERROR;
		}
		
		WaitSema(queue_sema);
	}
}

/** Uploads audio buffer to SPU
    @param buf     audio chunk
    @param buflen  size of chunk in bytes
    @returns positive number of bytes sent to processor or negative error status

    Plays an audio buffer; It will not interrupt a playing
    buffer, rather queue it up and play it as soon as possible without
    interfering with fluent streaming. The buffer and buflen are given
    in host format (i.e, 11025hz 8bit stereo.)
*/
int audsrv_play_audio(const char *buf, int buflen)
{
	int sent = 0;

	if (initialized == 0)
	{
		return -AUDSRV_ERR_NOT_INITIALIZED;
	}

	if (playing == 0)
	{
		/* audio is always playing, just change the volume */
		playing = 1;
		update_volume();
		readpos = writepos = 0;
	}

	//printf("play audio %d bytes, readpos %d, writepos %d avail %d\n", buflen, readpos, writepos, audsrv_available());

	/* limit to what's available, no crossing possible */
	buflen = MIN(buflen, audsrv_available());

	while (buflen > 0)
	{
		int copy = buflen;
		if (writepos >= readpos)
		{
			copy = MIN(ringbuf_size - writepos, buflen);
		}

		memcpy(ringbuf + writepos, buf, copy);
		buf = buf + copy;
		buflen = buflen - copy;
		sent = sent + copy;

		writepos = writepos + copy;
		if (writepos >= ringbuf_size)
		{
			/* rewind */
			writepos = 0;
		}
	}

	return sent;
}

/** Sets output volume
    @param vol      volume in SPU2 units [0 .. 0x3fff]
    @returns 0 on success, negative otherwise
*/
int audsrv_set_volume(int vol)
{
	if (vol < 0 || vol > MAX_VOLUME)
	{
		/* bad joke */
		return AUDSRV_ERR_ARGS;
	}

	core1_volume = vol;
	update_volume();
	return AUDSRV_ERR_NOERROR;
}

/** Shutdowns audsrv
    @returns AUDSRV_ERR_NOERROR
*/
int audsrv_quit()
{
	/* silence! */
	audsrv_stop_audio();

	/* stop transmission */
	sceSdSetTransCallback(SD_CORE_1, NULL);
	sceSdBlockTrans(SD_CORE_1, SD_BLOCK_TRANS_STOP, 0, 0, 0);

	/* stop playing thread */
	if (play_tid > 0)
	{
		TerminateThread(play_tid);
		DeleteThread(play_tid);
		play_tid = 0;
	}

	if (transfer_sema > 0)
	{
		DeleteSema(transfer_sema);
		transfer_sema = 0;
	}

	if (queue_sema > 0)
	{
		DeleteSema(queue_sema);
		queue_sema = 0;
	}

	return 0;
}

/** Plays CD audio track
    @param track    segment to play [1 .. 99]
    @returns error status
*/
int audsrv_play_cd(int track)
{
	if (initialized == 0)
	{
		return AUDSRV_ERR_NOT_INITIALIZED;
	}

	return AUDSRV_ERR_NOERROR;
}

/** Sets global CD volume
    @param left     volume for left channel
    @param right    volume for right channel
    @returns error status
*/
int audsrv_set_cdvol(int vol)
{
	printf("set cd volume %d\n", vol);

	if (vol < 0 || vol > MAX_VOLUME)
	{
		/* bad joke */
		return AUDSRV_ERR_ARGS;
	}

	core1_cdvolume = vol;
	update_volume();
	return AUDSRV_ERR_NOERROR;
}

/** Stops CD play
    @returns 0, always

    Stops CD from being played; this has no effect on other music
    audsrv is currently playing
*/
int audsrv_stop_cd()
{
	return 0;
}

/** RPC command handler.
    @param func     command (one of AUDSRV_x)
    @param data     pointer to data array
    @param size     size of data array (in bytes)
    @returns value depends on function invoked

    This is a single rpc handler, it unpacks the data array and calls 
    local functions.
*/
static void *rpc_command(int func, unsigned *data, int size)
{
	int ret;

	/* printf("audsrv: rpc command %d\n", func); */
	switch(func)
	{
		case AUDSRV_INIT:
		ret = audsrv_init();
		break;

		case AUDSRV_FORMAT_OK:
		ret = audsrv_format_ok(data[0], data[1], data[2]);
		break;

		case AUDSRV_SET_FORMAT:
		ret = audsrv_set_format(data[0], data[1], data[2]);
		break;

		case AUDSRV_WAIT_AUDIO:
		ret = audsrv_wait_audio(data[0]);
		break;

		case AUDSRV_PLAY_AUDIO:
		ret = audsrv_play_audio((const char *)&data[1], data[0]);
		break;

		case AUDSRV_STOP_AUDIO:
		ret = audsrv_stop_audio();
		break;

		case AUDSRV_SET_VOLUME:
		ret = audsrv_set_volume(data[0]);
		break;

		case AUDSRV_QUIT:
		ret = audsrv_quit();
		break;

		case AUDSRV_PLAY_CD:
		ret = audsrv_play_cd(data[0]);
		break;

		case AUDSRV_SET_CDVOL:
		ret = audsrv_set_cdvol(data[0]);
		break;

		case AUDSRV_STOP_CD:
		ret = audsrv_stop_cd();
		break;

		default:
		ret = -1;
		break;
	}

	data[0] = ret;
	return data;
}

/** RPC listener thread
    @param arg   not used

    This is the main RPC thread. Nothing fancy here.
*/
static void rpc_server_thread(void *arg)
{
	SifInitRpc(0);

	printf("audsrv: creating rpc server\n");

	SifSetRpcQueue(&qd, GetThreadId());
	SifRegisterRpc(&sd0, AUDSRV_IRX, (void *)rpc_command, rpc_buffer, 0, 0, &qd);
	SifRpcLoop(&qd);
}

static short rendered_left[256];
static short rendered_right[256];

/** Main playing thread
    @param arg   not used

    This is the main playing thread. It feeds the SPU with upsampled, demux'd
    audio data, from what has been queued beforehand. The stream is 
    constructed as a ring buffer. This thread only ends with TerminateThread,
    and is usually asleep, waiting for SPU to complete playing the current
    wave. SPU plays 1024 bytes blocks, which yields that this thread wakes
    and sleeps 187.5 times a second (alot!)
*/
static void play_thread(void *arg)
{
	int block;
	char *bufptr;
	int intr_state;
	int step;
	struct upsample_t up;
	upsampler_t upsampler = NULL;

	printf("starting play thread\n");
	while (1) 
	{
		if (format_changed)
		{
			upsampler = find_upsampler(core1_freq, core1_bits, core1_channels);
			format_changed = 0;
		}

		if (playing && upsampler != NULL)
		{
			if (readpos != writepos)
			{
				up.src = (const unsigned char *)ringbuf + readpos;
				up.left = rendered_left;
				up.right = rendered_right;
				step = upsampler(&up);

				readpos = readpos + step;
				if (readpos >= ringbuf_size)
				{
					/* wrap around */
					readpos = 0;
				}
			}
			else
			{
				/* whoops, not enough samples! */
				memset(rendered_left, '\0', sizeof(rendered_left));
				memset(rendered_right, '\0', sizeof(rendered_right));
			}
		}
		
		/* wait until it's safe to transmit another block */
		WaitSema(transfer_sema);

		/* suspend all interrupts */
		CpuSuspendIntr(&intr_state);

		/* one block is playing currently, other is idle */
		block = 1 - (sceSdBlockTransStatus(1, 0) >> 24);

		/* copy 512 bytes from left and right buffers, into spubuf */
		bufptr = spubuf + (block << 10);
		wmemcpy(bufptr, rendered_left, 512);
		wmemcpy(bufptr + 512, rendered_right, 512);

		CpuResumeIntr(intr_state);

		if (audsrv_available() >= (ringbuf_size / 10))
		{
			/* arbitrarily selected ringbuf_size / 10, to reduce
			 * number of semaphores signalled.
			 */
			SignalSema(queue_sema);
		}
	}
}

/** Helper function to easily create threads
    @param func       thread procedure
    @param priority   thread priority (usually 40)
    @param param      optional argument for thread procedure
    @returns thread_id (int), zero on error

    Creates a thread based on the given parameter. Upon completion,
    thread is started.
*/
static int create_thread(void *func, int priority, void *param)
{
	int tid;
	iop_thread_t thr;

	memset(&thr, '\0', sizeof(thr));
	thr.attr = TH_C;
	thr.thread = func;
	thr.option = (int)param;
	thr.priority = priority;
	thr.stacksize = 2048;
	thr.attr = 0x2000000;
	tid = CreateThread(&thr);
	if (tid <= 0) 
	{
		return 0;
	}

	StartThread(tid, 0);
	return tid;
}

/** IRX _start function
    @returns zero on success

    Initializes interrupts and the RPC thread. Oh, and greets the user.
*/
int _start()
{
	int rpc_tid;

	printf("audsrv: greetings from version " VERSION " !\n");

	/* enable SPU2 DMA interrupts */
	FlushDcache();
	CpuEnableIntr(0);
	EnableIntr(SPU_DMA_CHN0_IRQ);
	EnableIntr(SPU_DMA_CHN1_IRQ);
	EnableIntr(SPU_IRQ);

	/* create RPC listener thread */
	rpc_tid = create_thread(rpc_server_thread, 40, 0);
	printf("audsrv: rpc server thread %x started\n", rpc_tid);

	return 0;
}
